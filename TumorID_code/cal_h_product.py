# -*- coding: utf-8 -*-
"""
@author  : HYH
@E-mail  : huyuhan28@163.com
@className : cal_h_product
@describe  : TODO Likelihood values of all loci under hd / hp
"""

import cal_P_g_H
import cal_weighting
import numpy as np
import OSprocess
import logging


def products_hd(mx, x, AT,out_path, profile,dict_fd,sizefile,noc):
    '''
    :param    dict_fd: f(Hd) dictionary , generated by P_g_H_dict
    :return:  Likelihood values of all loci under hd
    '''
    loci_ls = OSprocess.listFilename_nosuffix(out_path)

    loci_ls.remove('AMEL')
    loci_ls.remove('DYS391')
    loci_ls.remove('Yindel')

    products_hd = np.array([])  # Likelihood values at each locus

    gf_locus_hd_p = dict_fd

    for locus in loci_ls:
        logging.debug('locus ： {}'.format(locus))

        # weighting of each locus , variable
        weighting = cal_weighting.weighting(mx, x, AT, out_path, profile, locus,sizefile,noc)
        print('weighting', weighting)


        locus_hd_product = np.sum(np.multiply(np.array(weighting), np.array(gf_locus_hd_p[locus])))
        products_hd = np.append(products_hd, locus_hd_product)

    logging.debug('products_hd: {}'.format(products_hd))
    return -np.sum(np.log(products_hd))

def get_index(g1com, refg):
        '''

        :param g1com: genotype of the first contributor, Two-dimensional List(float)
        :param refg: allele list of reference profile
        :return: Compare the first contributor with the reference profile, and get the index
        '''
        index = []
        i = 0
        for g1 in g1com:
            bool = (g1 == refg)

            if bool == True:
                index.append(i)
            i += 1
        return index


def get_comindex(g1com, refg,profile,locus):

    '''

    :return:    Compare the first contributor with the reference profile
                All alleles are identical，one allele are identical，no alleles are identical
    '''

    locus_allele_q = cal_P_g_H.get_allele_ls_99(profile, locus)
    # Determine if refg is a true subset of locus_allele_q
    ifInclude = set(refg) < set(locus_allele_q)

    if ifInclude == True:
        index = get_index(g1com, refg)

    else:
        cross = list(set(locus_allele_q).intersection(refg))
        if len(cross) == 1:
            refg = [cross[0], 99.0]
            index = get_index(g1com, refg)
        else:
            refg = [99.0, 99.0]
            index = get_index(g1com, refg)
    return index


def products_hp(mx, x, AT,out_path, sus_path, profile,dict_fp,sizefile,noc):
    '''
        :return:    Likelihood values of all loci under hp
    '''

    loci_ls = OSprocess.listFilename_nosuffix(out_path)

    loci_ls.remove('AMEL')
    loci_ls.remove('DYS391')
    loci_ls.remove('Yindel')


    products_hp = np.array([])

    gf_locus_hp_p = dict_fp


    for locus in loci_ls:
        logging.debug('位点 ： {}'.format(locus))


        weighting = cal_weighting.weighting(mx, x, AT, out_path, profile, locus,sizefile,noc)
        print('weighting',weighting)

        f = gf_locus_hp_p[locus]

        # index
        g1com = cal_P_g_H.get_G1com(out_path, locus, noc)[0]
        refg = cal_P_g_H.get_refls(sus_path, locus)
        ind = get_comindex(g1com, refg, profile, locus)

        if len(ind) != 0:
            hp_f = []
            hp_weighting = []
            for i in ind:
                hp_f.append(f[i])
                hp_weighting.append(weighting[i])


            locus_hp_product = sum(np.multiply(np.array(hp_f), np.array(hp_weighting)))
            products_hp = np.append(products_hp, locus_hp_product)

        else:
            #  If there is no 'QQ', and at the same time ref and evidence genotype do not match.
            #  That is, if ref cannot be interpreted without 'QQ', the procedure is launched
            print('【【【Quit the program because the loci do not match： {}】】】'.format(locus))
            logging.info('Quit the program because the loci do not match： {}'.format(locus))
            raise KeyError(f'【【Quit the program because the loci do not match： {locus}】】】')

    logging.debug('products_hp: {}'.format(products_hp))

    return  -np.sum(np.log(products_hp)) # Note the negative sign




